<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CM01: Simple Active Stress · Thunderbolt.jl</title><meta name="title" content="CM01: Simple Active Stress · Thunderbolt.jl"/><meta property="og:title" content="CM01: Simple Active Stress · Thunderbolt.jl"/><meta property="twitter:title" content="CM01: Simple Active Stress · Thunderbolt.jl"/><meta name="description" content="Documentation for Thunderbolt.jl."/><meta property="og:description" content="Documentation for Thunderbolt.jl."/><meta property="twitter:description" content="Documentation for Thunderbolt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Thunderbolt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Thunderbolt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Continuum Mechanics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>CM01: Simple Active Stress</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Commented-Program"><span>Commented Program</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#mechanics-tutorial_simple-active-stress-plain-program"><span>Plain program</span></a></li></ul></li><li><a class="tocitem" href="../cm02_prestress/">CM02: Prestressing (WIP)</a></li><li><a class="tocitem" href="../cm03_3d0d-coupling/">CM03: 0D Blood Circuit</a></li><li><a class="tocitem" href="../cm04_pericardium/">CM04: Pericadium (TODO)</a></li><li><a class="tocitem" href="../cm05_fourchambers/">CM05: Four Chamber (TODO)</a></li><li><a class="tocitem" href="../cm06_heartvalves/">CM06: Heart Valves (TODO)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Electrophysiology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ep01_spiral-wave/">EP01: Spiral Wave</a></li><li><a class="tocitem" href="../ep02_purkinje/">EP02: Purkinje Network (TODO)</a></li><li><a class="tocitem" href="../ep03_bidomain/">EP03: Defibrillation (TODO)</a></li><li><a class="tocitem" href="../ep04_geselowitz-ecg/">EP04: Monodomain ECG</a></li><li><a class="tocitem" href="../ep05_eikonal/">EP05: Eikonal Models (WIP)</a></li><li><a class="tocitem" href="../ep06_pacemaker/">EP06: Pacemakers (TODO)</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Topic Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Overview</a></li><li><a class="tocitem" href="../../topics/operators/">Operators</a></li><li><a class="tocitem" href="../../topics/couplers/">Couplers</a></li><li><a class="tocitem" href="../../topics/time-integration/">Time Integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">Overview</a></li><li><a class="tocitem" href="../../howto/benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../../howto/custom-ep-cell-model/">Adding EP Cell Models</a></li><li><a class="tocitem" href="../../howto/custom-stimulation-protocols/">Custom Stimulation Protocols</a></li><li><a class="tocitem" href="../../howto/custom-energies/">Adding Energies</a></li><li><a class="tocitem" href="../../howto/custom-sarcomere/">Adding Sarcomeres</a></li><li><a class="tocitem" href="../../howto/custom-elements/">Adding New Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api-reference/">Overview</a></li><li><a class="tocitem" href="../../api-reference/models/">Models</a></li><li><a class="tocitem" href="../../api-reference/mesh/">Mesh</a></li><li><a class="tocitem" href="../../api-reference/functions/">Functions</a></li><li><a class="tocitem" href="../../api-reference/problems/">Problems</a></li><li><a class="tocitem" href="../../api-reference/discretization/">Discretization</a></li><li><a class="tocitem" href="../../api-reference/operators/">Operators</a></li><li><a class="tocitem" href="../../api-reference/solver/">Solver</a></li><li><a class="tocitem" href="../../api-reference/utility/">Utility</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/">Overview</a></li><li><a class="tocitem" href="../../devdocs/element_interface/">Element Interface</a></li><li><a class="tocitem" href="../../devdocs/domain_management/">Domain management</a></li></ul></li><li><a class="tocitem" href="../../vroom/">Performance Tips</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Continuum Mechanics</a></li><li class="is-active"><a href>CM01: Simple Active Stress</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CM01: Simple Active Stress</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/termi-official/Thunderbolt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/termi-official/Thunderbolt.jl/blob/main/docs/src/literate-tutorials/cm01_simple-active-stress.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="mechanics-tutorial_simple-active-stress"><a class="docs-heading-anchor" href="#mechanics-tutorial_simple-active-stress">Mechanics Tutorial 1: Simple Contracting Ventricle</a><a id="mechanics-tutorial_simple-active-stress-1"></a><a class="docs-heading-anchor-permalink" href="#mechanics-tutorial_simple-active-stress" title="Permalink"></a></h1><p><img src="../contracting-left-ventricle.gif" alt="Contracting Left Ventricle"/></p><p>This tutorial shows how to perform a simulation for simple active mechanical behavior of heart chambers.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>A general model to simulate the contractile behavior of cardiact issues it the <em>active stress model</em>. Let us denote with <span>$\Omega_{\mathrm{H}}$</span> our heart domain and with <span>$u : \Omega_{\mathrm{H}} \to \mathbb{R}^3$</span> the unknown displacement field in three dimensional space. This induces a deformation gradient <span>$\bm{F} = \bm{I} + \nabla \bm{u}$</span>. With this formulation we can define a large class of active stress models in the first Piola-Kirchhoff stress with the following form:</p><p class="math-container">\[\bm{P} = \partial_{\bm{F}} \psi_{\mathrm{p}} + \mathcal{N}(\bm{\alpha}) \, \partial_{\bm{F}} \psi_{\mathrm{a}}\]</p><p>According to <a href="../../references/#Cha:1982:mlv">Chadwick [1]</a> the additive split of the stress in active and passive parts dates back to unpublished Peskin and has been popularized by <a href="../../references/#GucWalMcC:1993:mac">Guccione <em>et al.</em> [2]</a>.</p><h2 id="Commented-Program"><a class="docs-heading-anchor" href="#Commented-Program">Commented Program</a><a id="Commented-Program-1"></a><a class="docs-heading-anchor-permalink" href="#Commented-Program" title="Permalink"></a></h2><p>We start by loading Thunderbolt and LinearSolve to use a custom direct solver of our choice.</p><pre><code class="language-julia hljs">using Thunderbolt, LinearSolve</code></pre><p>Our goal is to simulate the contraction of a left ventricle with a very simple active stress formulation. Hence in a first step we need to load a suitable mesh. Thunderbolt can generate idealized geometries as follows.</p><pre><code class="language-julia hljs">mesh = generate_ideal_lv_mesh(11,2,5;
    inner_radius = 0.7,
    outer_radius = 1.0,
    longitudinal_upper = 0.2,
    apex_inner = 1.3,
    apex_outer = 1.5
);</code></pre><p>Here the first 3 parameters control the number of elements in circumferential, radial and longitudinal directions. The number of elements is very low, so users have an easy time to play around with it. For scientific studies the mesh needs to be finer, such that the simulation converges properly. The remaining parameters control the chamber geometry shape itself.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We can also load realistic geometries with external formats. For this simply use either FerriteGmsh.jl or one of the loader functions stated in the <a href="../../api-reference/mesh/#mesh-utility-api">mesh API</a>.</p></div></div><p>Next we will define a coordinate system, which helps us to work with cardiac geometries. This way we can reuse different methods, like for example fiber generators, across geometries.</p><pre><code class="language-julia hljs">coordinate_system = compute_lv_coordinate_system(mesh);</code></pre><p>In this coordinate system we will now create a microstructure with linearly varying helix angle in transmural direction. The compute microstructure field will be generated on the function space of piecewise continuous first order Lagrange polynomials.</p><pre><code class="language-julia hljs">microstructure = create_simple_microstructure_model(
    coordinate_system,
    LagrangeCollection{1}()^3;
    endo_helix_angle = deg2rad(60.0),
    epi_helix_angle = deg2rad(-60.0),
);</code></pre><p>Now we describe the model which we want to use. The models provided by Thunderbolt are designed to be highly modular, so you can quickly swap out individual component or compose models with each other. For the active stress formulation we need first the active and passive material models. For this tutorial we use the models described by Guccione.</p><pre><code class="language-julia hljs">passive_material_model = Guccione1991PassiveModel()
active_material_model  = Guccione1993ActiveModel();</code></pre><p>Furthermore we need to describe the calcium field and associate it with the sarcomere model. To simplify this tutorial we will use an analytical calcium profile. Note that we can also use experimental data or a precomputed calcium profile here, too, by simply changing the function implementation below.</p><pre><code class="language-julia hljs">function calcium_profile_function(x::LVCoordinate,t)
    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)
    ca_peak(x)                          = 1.0
    if 0 ≤ t ≤ 300.0
        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)
    elseif t ≤ 500.0
        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)
    else
        return 0.0
    end
end
calcium_field = AnalyticalCoefficient(
    calcium_profile_function,
    CoordinateSystemCoefficient(coordinate_system),
);</code></pre><p>We will use for a very simple sarcomere model which is constant in the calcium concentration. Note that a using a sarcomere model which has evoluation equations or rate-dependent terms will require different solvers.</p><pre><code class="language-julia hljs">sarcomere_model = ConstantStretchModel(;calcium_field);</code></pre><p>Now we have everything set to describe our active stress model by passing all the model components into it.</p><pre><code class="language-julia hljs">active_stress_model = ActiveStressModel(
    passive_material_model,
    active_material_model,
    sarcomere_model,
    microstructure,
);</code></pre><p>Next we define some boundary conditions. In order to have a very rough approximation of the effect of the pericardium, we use a Robin boundary condition in normal direction.</p><pre><code class="language-julia hljs">weak_boundary_conditions = (NormalSpringBC(1.0, &quot;Epicardium&quot;),)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(NormalSpringBC(1.0, &quot;Epicardium&quot;),)</code></pre><p>We finalize the mechanical model by assigning a symbol to identify the unknown solution field and connect the active stress model with the weak boundary conditions.</p><pre><code class="language-julia hljs">mechanical_model = StructuralModel(:displacement, active_stress_model, weak_boundary_conditions)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StructuralModel{ActiveStressModel{Guccione1991PassiveModel{SimpleCompressionPenalty{Float64}}, Guccione1993ActiveModel, ConstantStretchModel{Float64, AnalyticalCoefficient{typeof(Main.var&quot;Main&quot;.calcium_profile_function), CoordinateSystemCoefficient{LVCoordinateSystem{Float64, DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}, LagrangeCollection{1}}}}}, OrthotropicMicrostructureModel{FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}, FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}, FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}}}, Tuple{NormalSpringBC}}(:displacement, ActiveStressModel{Guccione1991PassiveModel{SimpleCompressionPenalty{Float64}}, Guccione1993ActiveModel, ConstantStretchModel{Float64, AnalyticalCoefficient{typeof(Main.var&quot;Main&quot;.calcium_profile_function), CoordinateSystemCoefficient{LVCoordinateSystem{Float64, DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}, LagrangeCollection{1}}}}}, OrthotropicMicrostructureModel{FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}, FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}, FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}}}(Guccione1991PassiveModel{SimpleCompressionPenalty{Float64}}(0.1, 29.8, 14.9, 14.9, 9.3, 19.2, 14.4, SimpleCompressionPenalty{Float64}(50.0)), Guccione1993ActiveModel(135.0, 1.45, 1.8, 4.35, 4.35, 3.8), ConstantStretchModel{Float64, AnalyticalCoefficient{typeof(Main.var&quot;Main&quot;.calcium_profile_function), CoordinateSystemCoefficient{LVCoordinateSystem{Float64, DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}, LagrangeCollection{1}}}}}(1.0, AnalyticalCoefficient{typeof(Main.var&quot;Main&quot;.calcium_profile_function), CoordinateSystemCoefficient{LVCoordinateSystem{Float64, DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}, LagrangeCollection{1}}}}(Main.var&quot;Main&quot;.calcium_profile_function, CoordinateSystemCoefficient{LVCoordinateSystem{Float64, DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}, LagrangeCollection{1}}}(LVCoordinateSystem{Float64, DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}, LagrangeCollection{1}}(DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}(SubDofHandler{DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}}[SubDofHandler{DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}}(DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}(#= circular reference @-3 =#), OrderedCollections.OrderedSet{Int64}([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  101, 102, 103, 104, 105, 106, 107, 108, 109, 110]), [:coordinates], Interpolation[Lagrange{RefHexahedron, 1}()], Int64[], 8), SubDofHandler{DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}}(DofHandler{3, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}}(#= circular reference @-3 =#), OrderedCollections.OrderedSet{Int64}([111, 112, 113, 114, 115, 116, 117, 118, 119, 120  …  123, 124, 125, 126, 127, 128, 129, 130, 131, 132]), [:coordinates], Interpolation[Lagrange{RefPrism, 1}()], Int64[], 6)], [:coordinates], [1, 2, 3, 4, 5, 6, 7, 8, 2, 9  …  42, 201, 63, 65, 200, 42, 4, 201, 65, 46], [1, 9, 17, 25, 33, 41, 49, 57, 65, 73  …  953, 959, 965, 971, 977, 983, 989, 995, 1001, 1007], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  2, 2, 2, 2, 2, 2, 2, 2, 2, 2], true, Thunderbolt.SimpleMesh{3, Union{Hexahedron, Wedge}, Float64}(Grid{3, Union{Hexahedron, Wedge}, Float64}(Union{Hexahedron, Wedge}[Hexahedron((1, 2, 13, 12, 34, 35, 46, 45)), Hexahedron((2, 3, 14, 13, 35, 36, 47, 46)), Hexahedron((3, 4, 15, 14, 36, 37, 48, 47)), Hexahedron((4, 5, 16, 15, 37, 38, 49, 48)), Hexahedron((5, 6, 17, 16, 38, 39, 50, 49)), Hexahedron((6, 7, 18, 17, 39, 40, 51, 50)), Hexahedron((7, 8, 19, 18, 40, 41, 52, 51)), Hexahedron((8, 9, 20, 19, 41, 42, 53, 52)), Hexahedron((9, 10, 21, 20, 42, 43, 54, 53)), Hexahedron((10, 11, 22, 21, 43, 44, 55, 54))  …  Wedge((200, 13, 14, 201, 24, 25)), Wedge((200, 14, 15, 201, 25, 26)), Wedge((200, 15, 16, 201, 26, 27)), Wedge((200, 16, 17, 201, 27, 28)), Wedge((200, 17, 18, 201, 28, 29)), Wedge((200, 18, 19, 201, 29, 30)), Wedge((200, 19, 20, 201, 30, 31)), Wedge((200, 20, 21, 201, 31, 32)), Wedge((200, 21, 22, 201, 32, 33)), Wedge((200, 22, 12, 201, 33, 23))], Node{3, Float64}[Node{3, Float64}([0.21631189606246318, 0.0, 1.2363734711836996]), Node{3, Float64}([0.1819731467559584, 0.11694704031258034, 1.2363734711836996]), Node{3, Float64}([0.08985920911525085, 0.19676422163421756, 1.2363734711836996]), Node{3, Float64}([-0.03078439250471708, 0.21411015285654575, 1.2363734711836996]), Node{3, Float64}([-0.14165416701656083, 0.1634776233769691, 1.2363734711836996]), Node{3, Float64}([-0.20754974438116286, 0.06094210355289533, 1.2363734711836996]), Node{3, Float64}([-0.20754974438116292, -0.06094210355289527, 1.2363734711836996]), Node{3, Float64}([-0.14165416701656086, -0.16347762337696908, 1.2363734711836996]), Node{3, Float64}([-0.03078439250471713, -0.21411015285654572, 1.2363734711836996]), Node{3, Float64}([0.08985920911525075, -0.19676422163421758, 1.2363734711836996])  …  Node{3, Float64}([-0.6228095682844902, 0.718760557376906, -0.463525491562421]), Node{3, Float64}([-0.9125320448954817, 0.26794358403653645, -0.463525491562421]), Node{3, Float64}([-0.9125320448954818, -0.2679435840365362, -0.463525491562421]), Node{3, Float64}([-0.6228095682844904, -0.7187605573769059, -0.463525491562421]), Node{3, Float64}([-0.13534945430529885, -0.9413761322695258, -0.463525491562421]), Node{3, Float64}([0.3950831550822797, -0.8651114366124778, -0.463525491562421]), Node{3, Float64}([0.8000796542554138, -0.5141799724162845, -0.463525491562421]), Node{3, Float64}([0.0, 0.0, 1.3]), Node{3, Float64}([0.0, 0.0, 1.4]), Node{3, Float64}([0.0, 0.0, 1.5])], Dict{String, OrderedCollections.OrderedSet{Int64}}(), Dict{String, OrderedCollections.OrderedSet{Int64}}(&quot;MyocardialAnchor1&quot; =&gt; OrderedCollections.OrderedSet{Int64}([166]), &quot;Apex&quot; =&gt; OrderedCollections.OrderedSet{Int64}([201]), &quot;ApexInOut&quot; =&gt; OrderedCollections.OrderedSet{Int64}([199, 201]), &quot;MyocardialAnchor2&quot; =&gt; OrderedCollections.OrderedSet{Int64}([188]), &quot;MyocardialAnchor3&quot; =&gt; OrderedCollections.OrderedSet{Int64}([169]), &quot;MyocardialAnchor4&quot; =&gt; OrderedCollections.OrderedSet{Int64}([175])), Dict{String, OrderedCollections.OrderedSet{FacetIndex}}(&quot;Epicardium&quot; =&gt; OrderedCollections.OrderedSet{FacetIndex}([FacetIndex((12, 4)), FacetIndex((13, 4)), FacetIndex((14, 4)), FacetIndex((15, 4)), FacetIndex((16, 4)), FacetIndex((17, 4)), FacetIndex((18, 4)), FacetIndex((19, 4)), FacetIndex((20, 4)), FacetIndex((21, 4))  …  FacetIndex((123, 5)), FacetIndex((124, 5)), FacetIndex((125, 5)), FacetIndex((126, 5)), FacetIndex((127, 5)), FacetIndex((128, 5)), FacetIndex((129, 5)), FacetIndex((130, 5)), FacetIndex((131, 5)), FacetIndex((132, 5))]), &quot;Base&quot; =&gt; OrderedCollections.OrderedSet{FacetIndex}([FacetIndex((89, 6)), FacetIndex((90, 6)), FacetIndex((91, 6)), FacetIndex((92, 6)), FacetIndex((93, 6)), FacetIndex((94, 6)), FacetIndex((95, 6)), FacetIndex((96, 6)), FacetIndex((97, 6)), FacetIndex((98, 6))  …  FacetIndex((101, 6)), FacetIndex((102, 6)), FacetIndex((103, 6)), FacetIndex((104, 6)), FacetIndex((105, 6)), FacetIndex((106, 6)), FacetIndex((107, 6)), FacetIndex((108, 6)), FacetIndex((109, 6)), FacetIndex((110, 6))]), &quot;Endocardium&quot; =&gt; OrderedCollections.OrderedSet{FacetIndex}([FacetIndex((1, 2)), FacetIndex((2, 2)), FacetIndex((3, 2)), FacetIndex((4, 2)), FacetIndex((5, 2)), FacetIndex((6, 2)), FacetIndex((7, 2)), FacetIndex((8, 2)), FacetIndex((9, 2)), FacetIndex((10, 2))  …  FacetIndex((112, 1)), FacetIndex((113, 1)), FacetIndex((114, 1)), FacetIndex((115, 1)), FacetIndex((116, 1)), FacetIndex((117, 1)), FacetIndex((118, 1)), FacetIndex((119, 1)), FacetIndex((120, 1)), FacetIndex((121, 1))])), Dict{String, OrderedCollections.OrderedSet{VertexIndex}}()), OrderedCollections.OrderedDict((1, 2, 12) =&gt; 1, (1, 2, 34) =&gt; 2, (2, 13, 35) =&gt; 3, (12, 13, 45) =&gt; 4, (1, 12, 34) =&gt; 5, (34, 35, 45) =&gt; 6, (2, 3, 13) =&gt; 7, (2, 3, 35) =&gt; 8, (3, 14, 36) =&gt; 9, (13, 14, 46) =&gt; 10…), OrderedCollections.OrderedDict((1, 2) =&gt; 1, (2, 13) =&gt; 2, (12, 13) =&gt; 3, (1, 12) =&gt; 4, (34, 35) =&gt; 5, (35, 46) =&gt; 6, (45, 46) =&gt; 7, (34, 45) =&gt; 8, (1, 34) =&gt; 9, (2, 35) =&gt; 10…), OrderedCollections.OrderedDict(1 =&gt; 1, 2 =&gt; 2, 13 =&gt; 3, 12 =&gt; 4, 34 =&gt; 5, 35 =&gt; 6, 46 =&gt; 7, 45 =&gt; 8, 3 =&gt; 9, 14 =&gt; 10…), OrderedCollections.OrderedDict{DataType, Int64}(Hexahedron =&gt; 110, Wedge =&gt; 22), OrderedCollections.OrderedDict{String, Thunderbolt.VolumetricSubdomainDesriptor}(&quot;&quot; =&gt; Thunderbolt.VolumetricSubdomainDesriptor(OrderedCollections.OrderedDict{Type, OrderedCollections.OrderedSet{CellIndex}}(Hexahedron =&gt; OrderedCollections.OrderedSet{CellIndex}(CellIndex[CellIndex(1), CellIndex(2), CellIndex(3), CellIndex(4), CellIndex(5), CellIndex(6), CellIndex(7), CellIndex(8), CellIndex(9), CellIndex(10)  …  CellIndex(101), CellIndex(102), CellIndex(103), CellIndex(104), CellIndex(105), CellIndex(106), CellIndex(107), CellIndex(108), CellIndex(109), CellIndex(110)]), Wedge =&gt; OrderedCollections.OrderedSet{CellIndex}(CellIndex[CellIndex(111), CellIndex(112), CellIndex(113), CellIndex(114), CellIndex(115), CellIndex(116), CellIndex(117), CellIndex(118), CellIndex(119), CellIndex(120)  …  CellIndex(123), CellIndex(124), CellIndex(125), CellIndex(126), CellIndex(127), CellIndex(128), CellIndex(129), CellIndex(130), CellIndex(131), CellIndex(132)])))), OrderedCollections.OrderedDict{String, Thunderbolt.SurfaceSubdomainDesriptor}(&quot;Epicardium&quot; =&gt; Thunderbolt.SurfaceSubdomainDesriptor(OrderedCollections.OrderedDict{Type, OrderedCollections.OrderedSet{FacetIndex}}(Hexahedron =&gt; OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((12, 4)), FacetIndex((13, 4)), FacetIndex((14, 4)), FacetIndex((15, 4)), FacetIndex((16, 4)), FacetIndex((17, 4)), FacetIndex((18, 4)), FacetIndex((19, 4)), FacetIndex((20, 4)), FacetIndex((21, 4))  …  FacetIndex((101, 4)), FacetIndex((102, 4)), FacetIndex((103, 4)), FacetIndex((104, 4)), FacetIndex((105, 4)), FacetIndex((106, 4)), FacetIndex((107, 4)), FacetIndex((108, 4)), FacetIndex((109, 4)), FacetIndex((110, 4))]), Wedge =&gt; OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((122, 5)), FacetIndex((123, 5)), FacetIndex((124, 5)), FacetIndex((125, 5)), FacetIndex((126, 5)), FacetIndex((127, 5)), FacetIndex((128, 5)), FacetIndex((129, 5)), FacetIndex((130, 5)), FacetIndex((131, 5)), FacetIndex((132, 5))]))), &quot;Base&quot; =&gt; Thunderbolt.SurfaceSubdomainDesriptor(OrderedCollections.OrderedDict{Type, OrderedCollections.OrderedSet{FacetIndex}}(Hexahedron =&gt; OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((89, 6)), FacetIndex((90, 6)), FacetIndex((91, 6)), FacetIndex((92, 6)), FacetIndex((93, 6)), FacetIndex((94, 6)), FacetIndex((95, 6)), FacetIndex((96, 6)), FacetIndex((97, 6)), FacetIndex((98, 6))  …  FacetIndex((101, 6)), FacetIndex((102, 6)), FacetIndex((103, 6)), FacetIndex((104, 6)), FacetIndex((105, 6)), FacetIndex((106, 6)), FacetIndex((107, 6)), FacetIndex((108, 6)), FacetIndex((109, 6)), FacetIndex((110, 6))]))), &quot;Endocardium&quot; =&gt; Thunderbolt.SurfaceSubdomainDesriptor(OrderedCollections.OrderedDict{Type, OrderedCollections.OrderedSet{FacetIndex}}(Hexahedron =&gt; OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((1, 2)), FacetIndex((2, 2)), FacetIndex((3, 2)), FacetIndex((4, 2)), FacetIndex((5, 2)), FacetIndex((6, 2)), FacetIndex((7, 2)), FacetIndex((8, 2)), FacetIndex((9, 2)), FacetIndex((10, 2))  …  FacetIndex((90, 2)), FacetIndex((91, 2)), FacetIndex((92, 2)), FacetIndex((93, 2)), FacetIndex((94, 2)), FacetIndex((95, 2)), FacetIndex((96, 2)), FacetIndex((97, 2)), FacetIndex((98, 2)), FacetIndex((99, 2))]), Wedge =&gt; OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((111, 1)), FacetIndex((112, 1)), FacetIndex((113, 1)), FacetIndex((114, 1)), FacetIndex((115, 1)), FacetIndex((116, 1)), FacetIndex((117, 1)), FacetIndex((118, 1)), FacetIndex((119, 1)), FacetIndex((120, 1)), FacetIndex((121, 1))])))), OrderedCollections.OrderedDict{String, Thunderbolt.InterfaceSubdomainDesriptor}()), 201), LagrangeCollection{1}(), [0.0, 0.0, 0.5944976258784387, 0.5944976258784387, 0.0, 0.0, 0.5729991976061601, 0.5729991976061602, 0.0, 0.5944976258784389  …  0.9999999999999999, 0.9999999999999999, 0.9999999999999999, 0.9999999999999999, 0.9999999999999999, 0.9999999999999999, 0.9999999999999999, 0.0, 0.5679402043235188, 0.9999999999999999], [0.5110320587520369, 0.5110320587544196, 0.48854064416926885, 0.48854064417482523, 0.6529580149205694, 0.652958014943065, 0.6515685029819588, 0.6515685030348671, 0.5110320587566374, 0.4885406441641186  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.1843708926942306, 0.0], [0.75, 0.6590909090909092, 0.6590909090909092, 0.75, 0.75, 0.6590909090909092, 0.6590909090909092, 0.75, 0.5681818181818182, 0.5681818181818182  …  0.38636363636363635, 0.2954545454545454, 0.20454545454545459, 0.11363636363636365, 0.022727272727272707, 0.9318181818181819, 0.8409090909090908, 0.0, 0.0, 0.0])))), OrthotropicMicrostructureModel{FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}, FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}, FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}}(FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}(Vec{3, Float64}[], Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}(LagrangeCollection{1}())), FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}(Vec{3, Float64}[], Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}(LagrangeCollection{1}())), FieldCoefficient{Vec{3, Float64}, Thunderbolt.ElementwiseData{Vec{3, Float64}, Vector{Vec{3, Float64}}, Vector{Int64}}, Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}}(Vec{3, Float64}[], Thunderbolt.VectorizedInterpolationCollection{3, LagrangeCollection{1}}(LagrangeCollection{1}())))), (NormalSpringBC(1.0, &quot;Epicardium&quot;),))</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>A full list of all models can be found in the <a href="https://termi-official.github.io/Thunderbolt.jl/dev/api-reference/models/#Solid-Mechanics">API reference</a>.</p></div></div><p>We now need to transform the space-time problem into a time-dependent problem by discretizing it spatially. This can be accomplished by the function semidiscretize, which takes a model and the disretization technique. Here we use a finite element discretization in space with first order Lagrange polynomials to discretize the displacement field.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>The discretization API does now play well with multiple domains right now and will be updated with a possible breaking change in future releases.</p></div></div><pre><code class="language-julia hljs">spatial_discretization_method = FiniteElementDiscretization(
    Dict(:displacement =&gt; LagrangeCollection{1}()^3),
)
quasistaticform = semidiscretize(mechanical_model, spatial_discretization_method, mesh);</code></pre><p>The remaining code is very similar to how we use SciML solvers. We first define our time domain, initial time step length and some dt for visualization.</p><pre><code class="language-julia hljs">dt₀ = 10.0
tspan = (0.0, 500.0)
dtvis = 25.0;</code></pre><p>This speeds up the CI # hide</p><p>Then we setup the problem. Since we have no time dependence in our active stress model the correct problem here is a quasistatic problem.</p><pre><code class="language-julia hljs">problem = QuasiStaticProblem(quasistaticform, tspan);</code></pre><p>Next we define the time stepper. Since there are no time derivatives appearing in our formulation we have to opt for a homotopy path method, which solve the time depentent problems adaptively. As our non-linear solver we choose the standard Newton-Raphson method and a direct solver for the inner linear system. For the theory behind homotopy path methods we refer to <a href="../../topics/time-integration/#theory_homotopy-path-methods">the corresponding theory manual on homotopy path methods</a></p><pre><code class="language-julia hljs">timestepper = HomotopyPathSolver(
    NewtonRaphsonSolver(
        max_iter=10,
        inner_solver=LinearSolve.UMFPACKFactorization(),
    )
);</code></pre><p>Now we initialize our time integrator as usual.</p><pre><code class="language-julia hljs">integrator = init(problem, timestepper, dt=dt₀, verbose=true, adaptive=true, dtmax=25.0);</code></pre><div class="admonition is-todo"><header class="admonition-header">Todo</header><div class="admonition-body"><p>The post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.</p></div></div><p>Finally we solve the problem in time.</p><pre><code class="language-julia hljs">io = ParaViewWriter(&quot;CM01_simple_lv&quot;);
for (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])
    @info t
    (; dh) = problem.f
    Thunderbolt.store_timestep!(io, t, dh.grid) do file
    Thunderbolt.store_timestep_field!(io, t, dh, u, :displacement)
    end
end;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: 0.0
[ Info: 25.0</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you want to see more details of the solution process launch Julia with Thunderbolt as debug module:</p><pre><code class="nohighlight hljs">JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl</code></pre></div></div><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[1]</dt><dd><div>R. Chadwick. <em>Mechanics of the left ventricle</em>. Biophysical journal <strong>39</strong>, 279–288 (1982).</div></dd><dt>[2]</dt><dd><div>J. M. Guccione, L. K. Waldman and A. D. McCulloch. <em>Mechanics of Active Contraction in Cardiac Muscle: Part II—Cylindrical Models of the Systolic Left Ventricle</em>. <a href="https://doi.org/10.1115/1.2895474">Journal of Biomechanical Engineering <strong>115</strong>, 82–90</a> (1993).</div></dd></dl></div><h2 id="mechanics-tutorial_simple-active-stress-plain-program"><a class="docs-heading-anchor" href="#mechanics-tutorial_simple-active-stress-plain-program">Plain program</a><a id="mechanics-tutorial_simple-active-stress-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#mechanics-tutorial_simple-active-stress-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../cm01_simple-active-stress.jl"><code>cm01_simple-active-stress.jl</code></a>.</p><pre><code class="language-julia hljs">using Thunderbolt, LinearSolve

mesh = generate_ideal_lv_mesh(11,2,5;
    inner_radius = 0.7,
    outer_radius = 1.0,
    longitudinal_upper = 0.2,
    apex_inner = 1.3,
    apex_outer = 1.5
);

coordinate_system = compute_lv_coordinate_system(mesh);

microstructure = create_simple_microstructure_model(
    coordinate_system,
    LagrangeCollection{1}()^3;
    endo_helix_angle = deg2rad(60.0),
    epi_helix_angle = deg2rad(-60.0),
);

passive_material_model = Guccione1991PassiveModel()
active_material_model  = Guccione1993ActiveModel();

function calcium_profile_function(x::LVCoordinate,t)
    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)
    ca_peak(x)                          = 1.0
    if 0 ≤ t ≤ 300.0
        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)
    elseif t ≤ 500.0
        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)
    else
        return 0.0
    end
end
calcium_field = AnalyticalCoefficient(
    calcium_profile_function,
    CoordinateSystemCoefficient(coordinate_system),
);

sarcomere_model = ConstantStretchModel(;calcium_field);

active_stress_model = ActiveStressModel(
    passive_material_model,
    active_material_model,
    sarcomere_model,
    microstructure,
);

weak_boundary_conditions = (NormalSpringBC(1.0, &quot;Epicardium&quot;),)

mechanical_model = StructuralModel(:displacement, active_stress_model, weak_boundary_conditions)

spatial_discretization_method = FiniteElementDiscretization(
    Dict(:displacement =&gt; LagrangeCollection{1}()^3),
)
quasistaticform = semidiscretize(mechanical_model, spatial_discretization_method, mesh);

dt₀ = 10.0
tspan = (0.0, 500.0)
dtvis = 25.0;

tspan = (0.0, dtvis);   # hide

problem = QuasiStaticProblem(quasistaticform, tspan);

timestepper = HomotopyPathSolver(
    NewtonRaphsonSolver(
        max_iter=10,
        inner_solver=LinearSolve.UMFPACKFactorization(),
    )
);

integrator = init(problem, timestepper, dt=dt₀, verbose=true, adaptive=true, dtmax=25.0);

io = ParaViewWriter(&quot;CM01_simple_lv&quot;);
for (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])
    @info t
    (; dh) = problem.f
    Thunderbolt.store_timestep!(io, t, dh.grid) do file
    Thunderbolt.store_timestep_field!(io, t, dh, u, :displacement)
    end
end;</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../cm02_prestress/">CM02: Prestressing (WIP) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 18 February 2025 21:35">Tuesday 18 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
